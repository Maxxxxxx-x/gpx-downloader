// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: copyfrom.go

package sqlc

import (
	"context"
)

// iteratorForBulkInsertFiles implements pgx.CopyFromSource.
type iteratorForBulkInsertFiles struct {
	rows                 []BulkInsertFilesParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkInsertFiles) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkInsertFiles) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Filename,
		r.rows[0].Sha512sum,
	}, nil
}

func (r iteratorForBulkInsertFiles) Err() error {
	return nil
}

func (q *Queries) BulkInsertFiles(ctx context.Context, arg []BulkInsertFilesParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"files"}, []string{"id", "filename", "sha512sum"}, &iteratorForBulkInsertFiles{rows: arg})
}

// iteratorForBulkInsertRecord implements pgx.CopyFromSource.
type iteratorForBulkInsertRecord struct {
	rows                 []BulkInsertRecordParams
	skippedFirstNextCall bool
}

func (r *iteratorForBulkInsertRecord) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForBulkInsertRecord) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].ID,
		r.rows[0].Userid,
		r.rows[0].Fileid,
		r.rows[0].Duration,
		r.rows[0].Distance,
		r.rows[0].Ascent,
		r.rows[0].Descent,
		r.rows[0].Elevationdiff,
		r.rows[0].Trails,
		r.rows[0].Rawdata,
	}, nil
}

func (r iteratorForBulkInsertRecord) Err() error {
	return nil
}

func (q *Queries) BulkInsertRecord(ctx context.Context, arg []BulkInsertRecordParams) (int64, error) {
	return q.db.CopyFrom(ctx, []string{"records"}, []string{"id", "userid", "fileid", "duration", "distance", "ascent", "descent", "elevationdiff", "trails", "rawdata"}, &iteratorForBulkInsertRecord{rows: arg})
}
