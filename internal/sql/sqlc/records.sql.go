// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: records.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type BulkInsertRecordParams struct {
	ID            string        `json:"id"`
	Userid        string        `json:"userid"`
	Fileid        string        `json:"fileid"`
	Duration      float32 `json:"duration"`
	Distance      float32 `json:"distance"`
	Ascent        float32 `json:"ascent"`
	Descent       float32 `json:"descent"`
	Elevationdiff float32 `json:"elevationdiff"`
	Trails        string   `json:"trails"`
	Rawdata       string   `json:"rawdata"`
}

const deleteRecordByFileId = `-- name: DeleteRecordByFileId :exec
DELETE FROM Records WHERE FileId = $1
`

func (q *Queries) DeleteRecordByFileId(ctx context.Context, fileid string) error {
	_, err := q.db.Exec(ctx, deleteRecordByFileId, fileid)
	return err
}

const deleteRecordById = `-- name: DeleteRecordById :exec
DELETE FROM Records WHERE Id = $1
`

func (q *Queries) DeleteRecordById(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteRecordById, id)
	return err
}

const deleteRecordsByUserId = `-- name: DeleteRecordsByUserId :exec
DELETE FROM Records WHERE UserId = $1
`

func (q *Queries) DeleteRecordsByUserId(ctx context.Context, userid string) error {
	_, err := q.db.Exec(ctx, deleteRecordsByUserId, userid)
	return err
}

const dropRecords = `-- name: DropRecords :exec
DELETE FROM Records
`

func (q *Queries) DropRecords(ctx context.Context) error {
	_, err := q.db.Exec(ctx, dropRecords)
	return err
}

const getRecordByFileId = `-- name: GetRecordByFileId :one
SELECT id, userid, fileid, duration, distance, ascent, descent, elevationdiff, trails, rawdata FROM Records WHERE FileId = $1 LIMIT 1
`

func (q *Queries) GetRecordByFileId(ctx context.Context, fileid string) (Record, error) {
	row := q.db.QueryRow(ctx, getRecordByFileId, fileid)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Fileid,
		&i.Duration,
		&i.Distance,
		&i.Ascent,
		&i.Descent,
		&i.Elevationdiff,
		&i.Trails,
		&i.Rawdata,
	)
	return i, err
}

const getRecordById = `-- name: GetRecordById :one
SELECT id, userid, fileid, duration, distance, ascent, descent, elevationdiff, trails, rawdata FROM Records WHERE Id = $1 LIMIT 1
`

func (q *Queries) GetRecordById(ctx context.Context, id string) (Record, error) {
	row := q.db.QueryRow(ctx, getRecordById, id)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Fileid,
		&i.Duration,
		&i.Distance,
		&i.Ascent,
		&i.Descent,
		&i.Elevationdiff,
		&i.Trails,
		&i.Rawdata,
	)
	return i, err
}

const getRecordsByTrail = `-- name: GetRecordsByTrail :many
SELECT id, userid, fileid, duration, distance, ascent, descent, elevationdiff, trails, rawdata FROM Records WHERE Trails = $1
`

func (q *Queries) GetRecordsByTrail(ctx context.Context, trails pgtype.Text) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByTrail, trails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Fileid,
			&i.Duration,
			&i.Distance,
			&i.Ascent,
			&i.Descent,
			&i.Elevationdiff,
			&i.Trails,
			&i.Rawdata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByUserId = `-- name: GetRecordsByUserId :many
SELECT id, userid, fileid, duration, distance, ascent, descent, elevationdiff, trails, rawdata FROM Records WHERE UserId = $1
`

func (q *Queries) GetRecordsByUserId(ctx context.Context, userid string) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByUserId, userid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Fileid,
			&i.Duration,
			&i.Distance,
			&i.Ascent,
			&i.Descent,
			&i.Elevationdiff,
			&i.Trails,
			&i.Rawdata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsOfUserOnTrail = `-- name: GetRecordsOfUserOnTrail :many
SELECT id, userid, fileid, duration, distance, ascent, descent, elevationdiff, trails, rawdata FROM Records WHERE UserId = $1 AND Trails = $2
`

type GetRecordsOfUserOnTrailParams struct {
	Userid string      `json:"userid"`
	Trails pgtype.Text `json:"trails"`
}

func (q *Queries) GetRecordsOfUserOnTrail(ctx context.Context, arg GetRecordsOfUserOnTrailParams) ([]Record, error) {
	rows, err := q.db.Query(ctx, getRecordsOfUserOnTrail, arg.Userid, arg.Trails)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Record{}
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.Userid,
			&i.Fileid,
			&i.Duration,
			&i.Distance,
			&i.Ascent,
			&i.Descent,
			&i.Elevationdiff,
			&i.Trails,
			&i.Rawdata,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertRecord = `-- name: InsertRecord :one
INSERT INTO Records (
    Id, UserId, FileId, Duration, Distance, Ascent, Descent, ElevationDiff, Trails, RawData
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, userid, fileid, duration, distance, ascent, descent, elevationdiff, trails, rawdata
`

type InsertRecordParams struct {
	ID            string        `json:"id"`
	Userid        string        `json:"userid"`
	Fileid        string        `json:"fileid"`
	Duration      pgtype.Float8 `json:"duration"`
	Distance      pgtype.Float8 `json:"distance"`
	Ascent        pgtype.Float8 `json:"ascent"`
	Descent       pgtype.Float8 `json:"descent"`
	Elevationdiff pgtype.Float8 `json:"elevationdiff"`
	Trails        pgtype.Text   `json:"trails"`
	Rawdata       pgtype.Text   `json:"rawdata"`
}

func (q *Queries) InsertRecord(ctx context.Context, arg InsertRecordParams) (Record, error) {
	row := q.db.QueryRow(ctx, insertRecord,
		arg.ID,
		arg.Userid,
		arg.Fileid,
		arg.Duration,
		arg.Distance,
		arg.Ascent,
		arg.Descent,
		arg.Elevationdiff,
		arg.Trails,
		arg.Rawdata,
	)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.Userid,
		&i.Fileid,
		&i.Duration,
		&i.Distance,
		&i.Ascent,
		&i.Descent,
		&i.Elevationdiff,
		&i.Trails,
		&i.Rawdata,
	)
	return i, err
}
